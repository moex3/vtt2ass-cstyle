#include "ass.h"

#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <stdlib.h>

#include "util.h"
#include "dyna.h"
#include "opts.h"
#include "cuepos.h"
#include "ass_ruby.h"
#include "font.h"

// for debug
#include <signal.h>

#define DEBUGBOX 1

#if DEBUGBOX == 1
#include "textextents.h"
#endif

static void ass_write_text(FILE *f, const struct cue *c);
static void ass_pos_line_in_box(const struct cue *c, const struct cuepos_box *box, struct ass_cue_pos *op);

static void ass_node_free(void *ptr)
{
    struct ass_node *n = ptr;
    //if (n->style)
        //free(n->style);
    if (n->text)
        free(n->text);
}

static int ass_node_compar(const void *d1, const void *d2)
{
    const struct ass_node *a = d1, *b = d2;
    if (a->start_ms < b->start_ms)
        return -1;
    if (a->start_ms > b->start_ms)
        return 1;

    /* Times are the same, do by layer */
    return a->layer - b->layer;
}

static void ass_ms_to_str(int64_t tms, int n, char out[n])
{
    int h, m, s, ms;
    h = tms / H_IN_MS;
    tms %= H_IN_MS;

    m = tms / M_IN_MS;
    tms %= M_IN_MS;

    s = tms / S_IN_MS;
    ms = tms % S_IN_MS;

    snprintf(out, n, "%d:%02d:%02d.%02d", h, m, s, ms / 10);
}

static void ass_write_dialog_prop(FILE *f, const struct ass_node *an)
{
    char ts_start[32], ts_end[32];
    const char *name = "";
    const char *stylename = "Default";
    if (an->style)
        stylename = an->style->name;

    ass_ms_to_str(an->start_ms, sizeof(ts_start), ts_start);
    ass_ms_to_str(an->end_ms, sizeof(ts_end), ts_end);

    fprintf(f,
            "Dialogue: %d,%s,%s,%s,%s,%04d,%04d,%04d,,"
            , an->layer, ts_start, ts_end, stylename, name, 0, 0, 0
           );
}

#if 1
static int ass_draw_box(int n, char out_tags[n], const struct ass_cue_pos *an7pos, const struct cuepos_box *box, const char *color)
{
    const char *col = color;
    if (col == NULL)
        col = "0000FF";

    return snprintf(out_tags, n, "{\\alpha&HB0&\\c&H%s&\\an7\\pos(%d,%d)\\p1}m %d %d l %d %d %d %d %d %d", col,
            an7pos->posx, an7pos->posy,
            box->left, box->top, box->left + box->width, box->top,
            box->left + box->width, box->top + box->height, box->left, box->top + box->height);
}

void ass_append_box(const struct cue *c, const struct ass_cue_pos *an7pos,
        const struct cuepos_box *box, const char *color, struct ass_params *ap)
{
    char text[1024];
    int text_len;
    struct ass_node anode = {
        .start_ms = c->time_start,
        .end_ms = c->time_end,
        .layer = 0,
        .style = ass_styles_get(ap->styles, "Default"),
    };

    text_len = ass_draw_box(sizeof(text), text, an7pos, box, color);
    assert(text_len < sizeof(text));

    anode.text = strdup(text);
    dyna_append(ap->ass_nodes, &anode);
}
#endif

static void ass_write_header(FILE *f)
{
    fprintf(f,
            "[Script Info]\n"
            "; Script generated by vtt2ass-cstyle\n"
            "; <link here>\n"
            "ScriptType: v4.00+\n"
            "Collisions: Normal\n"
            "ScaledBorderAndShadow: Yes\n"
            "PlayResX: %d\n"
            "PlayResY: %d\n"
            "LayoutResX: %d\n"
            "LayoutResY: %d\n"
            //"Kerning: Yes\n"
            "\n"
            "[V4+ Styles]\n"
            "Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n"
            , vinf->width, vinf->height, vinf->width, vinf->height);
}

static void ass_write_styles(FILE *f, const struct ass_params *ap)
{
    for (int i = 0; i < ap->styles->e_idx; i++) {
        char bord_color_str[12];
        const char *fontname;
        const struct ass_style *s = dyna_elem(ap->styles, i);

        ass_style_rgb_to_str(s->bord_color, bord_color_str);
        fontname = font_get_name(font_get_face(s->fontpath));

        fprintf(f,
                "Style: %s,%s,46,&H00FFFFFF,&H000000FF,%s,&H7F000000,0,0,0,0,100,100,%g,0,1,%g,%g,2,0,0,0,1\n"
                "\n", s->name, fontname, bord_color_str, s->fsp, s->bord, s->shad);
    }
}

static void ass_write_events_header(FILE *f)
{
    fputs(
            "[Events]\n"
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"
            ,f);
}

void ass_push_style_stack(struct stack *style_stack, const struct ass_style *style)
{
#define copyifset(tag) \
    if (style->tag##_set) { \
        new_style.tag = style->tag; \
        new_style.tag##_set = true; \
    }

    /* Pushing a style means copying the previous one, and overwriting with new values as needed */

    const struct ass_style *top_style = stack_top(style_stack);
    assert(top_style);
    struct ass_style new_style = *top_style;

    copyifset(fsp);
    copyifset(bord);
    copyifset(bord_color);
    copyifset(italic);
    copyifset(bold);
    copyifset(underline);
    copyifset(ruby_under);

    stack_push(style_stack, &new_style);

#undef copyifset
}

int style_to_inline_tags(const struct ass_style *style, int out_len, char out[out_len])
{
    printf("Applying styles\n");
#define apply_bool(tag, ass_tag) \
    if (style->tag##_set) { \
        w += snprintf(out + w, out_len - w, ass_tag "%d", style->tag); \
    }

    int w = 0;

    w += snprintf(out + w, out_len - w, "{");

    apply_bool(italic, "\\i");
    apply_bool(bold, "\\b");
    apply_bool(underline, "\\u");

    w += snprintf(out + w, out_len - w, "}");
    return w;
#undef apply_bool
}

static void class_to_style(const char *class_name, const struct ass_params *ap, struct ass_style *out)
{
    printf("Class to style\n");
    // This will have to be changed in the future...
    char cname_with_cue[128];

    sprintf(cname_with_cue, "::cue(.%s)", class_name);

    const struct cue_style *cs = cuestyle_get_by_selector(ap->cuestyles, cname_with_cue);
    if (cs == NULL) {
        fprintf(stderr, "Cannot find style with full class name: '%s'\n", cname_with_cue);
        return;
    }

    if (cs->italic) {
        out->italic = out->italic_set = true;
    }
    if (cs->ruby_position != RUBYPOS_UNSET) {
        out->ruby_under = cs->ruby_position == RUBYPOS_UNDER;
        out->ruby_under_set = true;
    }
}

void ass_node_to_style(const struct vtt_node *node, const struct ass_params *ap, struct ass_style *out)
{
    memset(out, 0, sizeof(*out));
    out->italic = node->type == VNODE_ITALIC;
    out->italic_set = node->type == VNODE_ITALIC;
    out->bold = node->type == VNODE_BOLD;
    out->bold_set = node->type == VNODE_BOLD;
    out->underline = node->type == VNODE_UNDERLINE;
    out->underline_set = node->type == VNODE_UNDERLINE;

    if (node->type == VNODE_CLASS) {
        for (int i = 0; i < node->class_names->e_idx; i++) {
            const char *class_name = *(char**)dyna_elem(node->class_names, i);
            class_to_style(class_name, ap, out);
        }
    }
}

static int ass_text_collect_tags_and_escape(const struct vtt_node *node, int n, char out[n], struct stack *style_stack, bool *have_ruby, const struct ass_params *ap)
{
    int w = 0;

    if (node->type == VNODE_TIMESTAMP)
        return 0;

    if (node->type == VNODE_TEXT) {

        w += style_to_inline_tags(stack_top(style_stack), n - w, out + w);

        char *nn = node->text, *pn = nn;
        while (*pn) {
            nn = strchr(pn, '\n');
            if (!nn) {
                w += snprintf(out + w, n - w, "%s", pn);
                if (w > n) return w;
                break;
            }
            w += snprintf(out + w, n - w, "%.*s\\N", (int)(nn - pn), pn);
            if (w > n) return w;
            pn = nn + 1;
        }
        return w;
    } else if (node->type == VNODE_RUBY_TEXT) {
        if (have_ruby)
            *have_ruby = true;
        return 0;
    } else if (node->type == VNODE_ITALIC) {
        struct ass_style ns = {
            .italic = true, .italic_set = true,
        };
        ass_push_style_stack(style_stack, &ns);
    } else if (node->type == VNODE_BOLD) {
        struct ass_style ns = {
            .bold = true, .bold_set = true,
        };
        ass_push_style_stack(style_stack, &ns);
    } else if (node->type == VNODE_UNDERLINE) {
        struct ass_style ns = {
            .underline = true, .underline_set = true,
        };
        ass_push_style_stack(style_stack, &ns);
    } else if (node->type == VNODE_CLASS) {
        struct ass_style ns = {0};
        for (int i = 0; i < node->class_names->e_idx; i++) {
            const char *class_name = *(char**)dyna_elem(node->class_names, i);
            printf("name: %s\n", class_name);
            class_to_style(class_name, ap, &ns);
        }
        ass_push_style_stack(style_stack, &ns);
    }

    for (int i = 0; node->childs && i < node->childs->e_idx; i++) {
        struct vtt_node *cn = dyna_elem(node->childs, i);

        w += ass_text_collect_tags_and_escape(cn, n - w, out + w, style_stack, have_ruby, ap);
        if (w > n) return w;
    }

    switch (node->type) {
    case VNODE_CLASS:
    case VNODE_ITALIC:
    case VNODE_BOLD:
    case VNODE_UNDERLINE:
        printf("Style Pop\n");
        stack_pop(style_stack);
        break;
    default:
        break;
    }

    return w;
}

/* Convert align for horizontal text into
 * align for vertical text */
static int ass_horiz_to_vert_align(int align)
{
#if 0
    int map[] = {
        [1] = 7, [4] = 8, [7] = 9,
        [2] = 4, [5] = 5, [8] = 6,
        [3] = 1, [6] = 2, [9] = 3,
    };
#endif
    // TODO this
    int map[] = {
        [1] = 3, [4] = 2, [7] = 9,
        [2] = 8, [5] = 5, [8] = 6,
        [3] = 9, [6] = 8, [9] = 3,
    };
    assert(align < ARRSIZE(map));
    int a = map[align];
    assert(a);
    return a;
}

static void ass_pos_line_in_box(const struct cue *c, const struct cuepos_box *box, struct ass_cue_pos *op)
{
    int alignmap[3][3] = {
        { 7, 8, 9 },
        { 4, 5, 6 },
        { 1, 2, 3 },
    };
    //BP;
    int xal = 0, yal = 0;
    int lc = util_count_node_lines(c->text_node);
    op->fs = 5 * (vinf->height / 100.0f);
    int text_height = lc * op->fs;
    bool is_wdh = c->writing_direction == WD_HORIZONTAL;

    if (is_wdh) {
        switch (c->text_align) {
        case TEXT_ALIGN_LEFT:
            xal = 0;
            op->posx = box->left;
            break;
        case TEXT_ALIGN_RIGHT:
            xal = 2;
            op->posx = box->left + box->width;
            break;
        default:
        case TEXT_ALIGN_CENTER:
            xal = 1;
            op->posx = box->left + box->width / 2;
            break;
        }

        if (true || IS_AUTO(c->line)) {
            yal = 2;
            op->posy = box->top + box->height;
        } else {
            switch (c->line_align) {
            case LINE_ALIGN_START: // spec
                yal = 0;
                op->posy = box->top;
                break;
            case LINE_ALIGN_CENTER:
                yal = 1;
                op->posy = box->top + box->height / 2;
                break;
            case LINE_ALIGN_END: // spec
                yal = 2;
                op->posy = box->top + box->height;
                break;
            default:
                assert(false && "Unhandled line align in pos_in_box");
                break;
            }
        }
    } else {
        /* Vertical text */
        enum cue_pos_align posalign = cuepos_compute_pos_align(c);
        bool is_right = c->writing_direction == WD_VERTICAL_GROW_RIGHT;

        if (false && IS_AUTO(c->line)) {
            xal = 2;
            op->posx = box->left + box->width;
        } else {
            switch (c->line_align) {
            case LINE_ALIGN_START: // spec
                yal = is_right ? 0 : 2;
                op->posx = box->left + box->width * is_right;
                break;
            case LINE_ALIGN_CENTER:
                yal = 1;
                op->posx = box->left + box->width / 2;
                break;
            case LINE_ALIGN_END: // spec
                yal = is_right ? 2 : 0;
                op->posx = box->left + box->width * is_right;
                break;
            default:
                assert(false && "Unhandled line align in pos_in_box");
                break;
            }
        }

        switch (c->text_align) {
        case TEXT_ALIGN_LEFT:
            xal = 0;
            op->posy = box->top;
            break;
        case TEXT_ALIGN_RIGHT:
            xal = 2;
            op->posy = box->top + box->height;
            break;
        default:
        case TEXT_ALIGN_CENTER:
            xal = 1;
            op->posy = box->top + box->height / 2;
            break;
        }
    }

#if 0
    if (c->writing_direction != WD_HORIZONTAL) {
        /* If vertical writing, adjust aligns
         * \an7 for horizontal is \an1 for vertical */
        if (yal == 0)
            yal = 2;
    }
#endif

    op->align = alignmap[yal][xal];
    op->logical_align = op->align;
    printf("Align is: %d\n", op->align);

    if (lc > 1) {
        if (op->posy + text_height > vinf->height &&
                (op->align == 7 || op->align == 8 || op->align == 9)) {
            /* Would be outside the video, shift it up */
            int extra = op->posy + text_height - vinf->height;
            op->posy -= extra;
            assert(false);
        }
    }
}

int ass_opt_tags_str(const struct cue *c, const struct ass_params *ap, int tags_size, char tags[tags_size])
{
    int r = 0;

    if (c->writing_direction != WD_HORIZONTAL) {
        /* Some kind of vertical */
        FT_Face font = font_get_face(ap->fontpath);
        const char *fontname = font_get_name(font);
        r += snprintf(tags + r, tags_size - r, "\\fn@%s\\frz270", fontname);
    }

    if (r < tags_size) {
        tags[r] = '\0';
    }
    return r;
}

static void ass_cue2ass(struct cue *c, struct ass_params *ap)
{
    char escaped_text[1024];
    char tag_text[1024];
    char tag2_text[128];
    bool have_ruby = false;
    struct ass_cue_pos pi = {0};
    struct cuepos_box boxp = {0};
    struct ass_style *style = ass_styles_get(ap->styles, "Default");
    struct ass_node anode = {
        .start_ms = c->time_start,
        .end_ms = c->time_end,
        .layer = 9,
        .style = style,
    };
    int escaped_text_len, tag_text_len, tag2_text_len;
    stack_init(style_stack, sizeof(struct ass_style), 30);
    stack_push(&style_stack, style);

    cuepos_apply_cue_settings(c, &boxp);
#if DEBUGBOX == 1
    if (opts_ass_debug_boxes) {
        struct ass_cue_pos boxpos = {0};
        ass_append_box(c, &boxpos, &boxp, "00FF00", ap);
    }
#endif
    ass_pos_line_in_box(c, &boxp, &pi);

    /* TODO: cont. here, add inline tags for classes here */
    escaped_text_len = ass_text_collect_tags_and_escape(c->text_node, sizeof(escaped_text), escaped_text, &style_stack, &have_ruby, ap);
    assert(escaped_text_len < sizeof(escaped_text));
    if (have_ruby) {
        /* If it has ruby, use ruby text rendering */
        ass_ruby_write(c, &pi, ap);
        return;
    }
    /* If no ruby, use the normal rendering */

    tag2_text_len = ass_opt_tags_str(c, ap, sizeof(tag2_text), tag2_text);
    assert(tag2_text_len < sizeof(tag2_text));
    tag_text_len = snprintf(tag_text, sizeof(tag_text), "{\\an%d\\fs%d\\pos(%d,%d)%s}", pi.align, pi.fs, pi.posx, pi.posy, tag2_text);
    assert(tag_text_len < sizeof(tag_text));

    anode.text = malloc(tag_text_len + escaped_text_len + 1);
    sprintf(anode.text, "%s%s", tag_text, escaped_text);

    dyna_append(ap->ass_nodes, &anode);

#if DEBUGBOX == 1
    if (opts_ass_debug_boxes) {
        char text[1024];
        char line[1024];
        struct ass_cue_pos an7pos;
        struct text_extents line_exts[64];
        int line_ext_count = 0;
        struct text_extents full_ext;

        ctxt_text(c->text_node, sizeof(text), text);
        const char *start = text;
        const char *end = strchr(text, '\n');
        while (end) {
            memset(line, 0, sizeof(line));
            memcpy(line, start, end - start);
            te_simple(style->fontpath, line, pi.fs, style->fsp, false, &line_exts[line_ext_count++]);
            start = end + 1;
            end = strchr(start, '\n');
        }
        if (*start) {
            memset(line, 0, sizeof(line));
            memcpy(line, start, strlen(start));
            te_simple(style->fontpath, line, pi.fs, style->fsp, false, &line_exts[line_ext_count++]);
        }

        util_combine_extents(line_ext_count, line_exts, &full_ext);
        util_cue_pos_to_an7(&pi, &full_ext, &an7pos);

        struct cuepos_box box = {
            .width = full_ext.width,
            .height = full_ext.height,
        };
        ass_append_box(c, &an7pos, &box, "FC19DA", ap);
    }
#endif

}

static void ass_write_ass_nodes(FILE *f, const struct dyna *ass_nodes)
{
    for (int i = 0; i < ass_nodes->e_idx; i++) {
        const struct ass_node *an = dyna_elem(ass_nodes, i);

        ass_write_dialog_prop(f, an);
        fputs(an->text, f);
        fputs("\n", f);
    }
}

static void text_shadow_to_bord(const struct cue_style *cs, struct ass_style *st, struct ass_params *ap)
{
    if (cs->text_shadow_count == 0)
        return;
    if (cs->text_shadow_count != 4) {
        fprintf(stderr, "Text shadow count is not 4, skipping it...\n");
        return;
    }

    /* A lot simpler implementation for now.
     * Only take the 1st entry into consideration */
    st->bord = abs(cs->text_shadow[0].xpos) + abs(cs->text_shadow[0].ypos);
    st->bord_color = util_colorname_to_rgb(cs->text_shadow[0].color);

    /* will get ignored, but w/e */
    st->bord_color_set = st->bord_set = true;
}

static void create_default_style(struct ass_params *ap)
{
    struct ass_style *s = ass_styles_add(ap->styles, "Default");
    s->fontpath = strdup(ap->fontpath);
    s->fsp = 0;
    /* Rest can be zero */

    /* Set every element as set */
    s->fsp_set = s->bord_set = s->bord_color_set = s->italic_set = 
        s->bold_set = s->underline_set = true;

    if (opts_ass_border_size != -1) {
        /* Have border option, use that */
        s->bord = opts_ass_border_size;
        return;
    }

    /* Otherwise, try select it from the vtt styles */
    const struct cue_style *cs = cuestyle_get_by_selector(ap->cuestyles, "::cue()");
    if (cs) {
        text_shadow_to_bord(cs, s, ap);
    } else {
        /* Set a default border size */
        s->bord_color = 0; /* black */
        s->bord = (int)(vinf->height / 300.0f);
    }

}

int ass_write(struct dyna *cues, struct dyna *cstyles, const struct video_info *video_info, const char *fontpath, const char *fname)
{
    struct ass_params ap = {
        .fontpath = fontpath,
        .cuestyles = cstyles,
    };
    FILE *f = fopen(fname, "w");
    if (f == NULL)
        return -1;

    cuepos_set_video_info(video_info);

    ap.styles = ass_styles_create();
    create_default_style(&ap);

    ap.ass_nodes = dyna_create_size(sizeof(struct ass_node), 256);
    dyna_set_free_fn(ap.ass_nodes, ass_node_free);

    for (int i = 0; i < cues->e_idx; i++) {
        struct cue *c = dyna_elem(cues, i);
        struct ass_node anode = {0};

        ass_cue2ass(c, &ap);
    }

    printf("Sorting lines...\n");
    /* Maybe we could do an array of pointers here, like a view */
    qsort(ap.ass_nodes->data, ap.ass_nodes->e_idx, ap.ass_nodes->e_size, ass_node_compar);

    ass_write_header(f);
    ass_write_styles(f, &ap);
    ass_write_events_header(f);
    ass_write_ass_nodes(f, ap.ass_nodes);

    fclose(f);
    dyna_destroy(ap.ass_nodes);
    ass_styles_destroy(ap.styles);
    return 0;
}
